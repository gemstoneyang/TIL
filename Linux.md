
# man 페이지의 섹션 구분

| 섹션 | 분류 |
| --- | --- |
| 1 | 실행 가능한 프로그램이나 셸 명령어 |
| 2 | 시스템 콜 |
| 3 | 라이브러리 함수 |
| 4 | 특별한 파일들(디바이스 파일 등) |
| 5 | 파일 포맷 |
| 6 | 게임 |
| 7 | 규격 등 |
| 8 | 시스템 관리용 명령어 |
- 콘솔에서 `man <찾을 명령>` 을 입력하면 섹션 1부터 차례대로 조사해서 제일 먼저 발견한 섹션의 페이지를 표시해 준다.
- `man <섹션> <찾을 명령>` 과 같이 중간에 섹션 번호를 넣으면, 해당 섹션에 한해서만 검색한다.
- 여러 섹션에 동일한 이름의 페이지가 존재할 수도 있다.
    - printf의 경우 섹션 1과 3에 존재한다.
    - `man printf` 라고 입력하면 제일 먼저 발견되는 섹션 1이 표시된다.
    - 라이브러리 함수과 관련된 printf를 보고 싶으면 `man 3 printf` 라고 입력해야 한다.
- man의 섹션 번호는 리눅스나 유닉스와 관련된 문서에서도 자주 사용된다.
    
    → 명령어 printf는 `printf(1)` , 라이브러리 함수 printf는 `printf(3)` 라고 표시


# 커널

- 커널(kernel)이란, 사물의 중심이란 뜻을 가지며 운영체제의 중심을 의미한다.
- 보통 커널은 하나의 프로그램으로 구성되어 컴퓨터를 구성하는 모든 하드웨어와 소프트웨어를 관리한다.
- 리눅스의 루트 경로(/)나 /boot 디렉토리에서 `ls` 명령어를 실행해 보면 `vmlinuz` 라는 이름의 파일이 있는데 이것이 리눅스 커널의 본체다.
- 엄밀히 말해 ‘리눅스'라고 하면 오직 커널만을 의미한다.

# 시스템 콜

- 하드웨어를 직접 다루는 건 커널만이 할 수 있다.
- 일반 프로그램이 하드웨어를 조작하기 위해서는 커널에 의뢰해야만 한다.
- 일반 프로그램이 커널에 디바이스 조작 작업을 의뢰하기 위해 사용하는 것이 **시스템 콜**(system calll)이다.
    - 시스템 콜이라는 이름에서 시스템은 커널을 의미한다.
- 시스템 콜의 종류는 아래와 같다.
    
    `open, read, write, fork, exec, stat, unlink`
    
- 리눅스의 핵심에는 커널이 있고 이 커널에 일을 맡기기 위해 시스템 콜을 사용한다.
# 파일 시스템

## 파일

- 리눅스에서 파일은 세 가지 경우로 나누어 생각해 볼 수 있다.
    1. 넓은 의미의 파일
    2. 좁은 의미의 파일
    3. 스트림

## 넓은 의미의 파일

  - `ls` 명령어를 치면 나오는 텍스트 파일, 바이너리 파일, 디렉터리, 심볼릭 링 크 모두 파일이다.

### 보통 파일

- 가장 일반적인 것으로 데이터가 들어 있는 파일이다.
- regular file 혹은 normal file이라고 한다.
- 좁은 의미에서 파일의 정의는 보통 이러한 보통 파일만을 말한다.
- 사람의 관점에서는 텍스트 파일, 영상 파일, 이미지 파일  등으로 구분할 수 있지만, 커널 입장에서는 그저 같은 보통 파일이다.

### 디렉터리

- 디렉터리(directory)는 다른 파일(넓은 의미의 파일)들을 담아 둘 수 있는 파일이다.
- 유닉스에서는 전통적으로 디렉터리의 데이터를 단순한 바이트 열로 읽는 것이 가능했지만 리눅스에서는 금지했다.

### 심볼릭 링크

- 심볼릭 링크(symbolic link)란, 다른 파일을 가리키는 파일을 말한다.
- 소프트 링크(soft link)라고도 한다.
- 심볼릭 링크 파일을 열면, 커널이 자동으로 연결된 파일을 열어 준다.
- 심볼릭 링크를 사용하면 파일아니 디렉터리에 다른 이름, 즉 별명을 부여할 수 있다.

### 디바이스 파일

- 디바이스 파일(device file)이란, 디바이스(하드웨어)를 파일로 표현한 것이다.
- 예를 들어 디바이스 파일 `/dev/sda` 는 첫 번째 SSD 혹은 HDD를 의마한다.
- 디바이스 파일은 다루는 하드웨어에 따라 **문자 디바이스 파일**(character device file)과 **블록 디바이스 파일**(block device file)이 있다.
    - 차이점은 원하는 시점에 원하는 곳에 접근할 수 있는지다.
    - SSD와 HDD는 대표적인 블록 디바이스다.
    - 프린터나 모뎀은 문자 디바이스다.

### 명명된 파이프

- 명명된 파이프(named pipe)는 프로세스 간 통신에 사용되는 파일이다.
- FIFO라고도 불린다.
- 명명된 파이프는 사용 빈도가 높지 않다.

### UNIX 도메인 소켓

- 유닉스 도메인 소켓도 프로세스 간 통신에 사용되는 파일이다.
- 현재는 TCP 소켓으로 대체되었다.

## 메타 정보

- 파일에는 데이터 그 자체 외에도 다양한 정보가 존재한다.
- 파일의 종류, 권한, 크기, 마지막 수정 시간이 존재한다.

## 파일에 대한 특징 정리

- 어떤 데이터를 보유한다.
- 메타 정보가 있다
- 이름(경로)으로 지정할 수 있다.

⇒ 이와 같은 특징을 가지는 파일을 관리하는 시스템이 바로 파일 시스템이다.

## 파일 시스템과 마운트

- 파일 시스템은 당연하게도 SSD나 HDD, USB 메모리처럼 물리적인 기억 장치에 존재한다.
- 예를 들어 SSD나 HDD의 경우, 먼저 디스크를 **파티션**(partition) 단위로 나눠 그 위에 파일 시스템을 얹어서 **마운트**(mount)하면 거대한 디렉터리 트리가 생성된다.
- 리눅스에서 사용할 수 있는 파일 시스템 중 몇 가지는 다음과 같다.
    - ext4 : 현재 리눅스에서 가장 일반적으로 사용되는 파일 시스템
    - xfs : 구 SGI 사가 제공한 저널링 파일 시스템
    - btrfs : 리눅스 향 copy-on-write B tree 파일 시스템
    - 이 외에도 물리적인 디바이스가 존재하지 않는 가상 파일 시스템(pseudo file system)이 있다.

# 프로세스

## 프로세스

- 프로세스 :  실행 중인 프로그램
- 프로그램 : 파일 형태로 존재하는 실행 가능한 파일
- 프로그램을 실행하면 그때마다 새로운 프로세스가 만들어진다.
    
    = 하나의 프로그램이 있으면 새로운 프로세스를 계속 만들 수 있다.
    

## 프로세스 ID

- 하나의 프로그램으로 여러 개의 프로세스를 만들 수 있다면 프로그램 이름만으로는 프로세스를 서로 구별할 수 없음
- 프로세스 ID
    - 시스템에서 돌고 있는 모든 프로세스 간에 중복되지 않도록 할당된 번호
    - 프로세스 ID를 사용하여 특정 프로세스를 지정할 수 있음 (unique)

## 시그널

- 프로세스 ID가 사용되는 대표적인 예
- `Ctrl + C` 를 누르면 프로세스가 멈추는데 이때 사용된 기능이 바로 시그널.
- `Ctrl + C` 를 누르면 커널이 해당 프로세스에 인터럽트 시그널(SIGINT)을 보내, 이를 전달받은 프로세스가 자발적으로 종료됨
- 시그널은 예전부터 유닉스에 존재했고 리눅스 프로그래밍에서 매우 중요한 위치를 차지함

# 스트림

- 스트림(stream)은 무언인가의 좁은 흐름을 뜻한다.
- 리눅스의 스트림은 바이트 스트림(byte stream)을 말한다.

## 파일에 연결된 스트림

- 프로세스가 파일의 내용 읽기
    1. 파일에 연결된 스트림을 만들도록 커널에 (시스템 콜을 사용하여) 의뢰한다.
    2. 시스템 콜을 사용하여 파일의 내용을 읽는다.
- 스트림에서 바이트 열을 꺼내는 것을 읽는다(read)라고 한다.
- 스트림에서 바이트 열을 흘려보내는 것을 쓴다(write)라고 한다.

## 디바이스에 연결된 스트림

- 스트림의 끝에는 보통 파일(regular file) 외에도 바이트 열이 흘러갈 수 있는 곳이라면 어떤 것도 스트림에 연결될 수 있다.
- SSD나 HHD, 키보드와 같은 하드웨어도 스트림이 연결될 수 있다.

## 파이프

- 스트림은 바이트 열이 흘러다니는 곳이다.
- 스트림의 양 끝에 프로세스가 있는 스트림을 파이프(pipe)라고 한다.
- 파이프 사용법
    1. 각 명령어를 독립된 프로세스로 동시에 실행한다.
    2. 각 프로세스를 스트림(파이프)으로 연결한다.

## 네트워크 통신

- 스트림은 바이트 열의 통로고, 이 바이트 열이 잘 수송될 수 있다면 스트림이 다른 컴퓨터까지 연결될 수도 있다. → 네트워크 통신 (network communication)
- 네트워크 통신에서는 프로세스 간 스트림 연결이 많지만 파일이 연결될 수도 있다.

## 프로세스 간 통신

- 파이프나 네트워크 통신과 같이 프로세스 간에 스트림을 통해 데이터를 주고받으며 소통하는 것을 프로세스 간 통신(IPC)이라 한다.
- 스트림은 프로세스 간 통신에 있어 중요한 역할을 수행한다.
- 스트림만이 유일한 프로세스 간 통신 방법은 아니다. (ex : POSIX IPC)

# 프로세스 API

## fork(2)

- 프로세스 자신을 복제해서 새로운 프로세스를 만드는 시스템 콜
- fork()를 호출하면 커널이 프로세스를 복제해서 두 개의 프로세스로 분리함
    - 이 시점에서 ‘복제 이전 프로세스’와 ‘복제 이후 프로세스’ 모두 fork() 호출이 끝난 상태
    - 둘 다 fork() 이후의 코드가 실행됨
- 부모 프로세스(parent process)
    - fork() 전부터 존재하던 프로세스
    - fork()의 반환값은 자식 프로세스의 프로세스 ID 값(양수)
- 자식 프로세스(child process)
    - fork()로 복제해서 만들어진 프로세스
    - fork()의 반환값은 0
- fork()가 실패한 경우 자식 프로세스가 생성되지 않고 부모 프로세스에 -1 반환

## exec

- 프로세스 자기 자신을 새로운 프로그램으로 덮어 쓰는 시스템 호출
- exec를 실행하면 그 시점에서 현재 실행 중인 프로그램이 소멸하고, 새로운 프로그램을 로드하여 실행
- fork() 후 즉시 exec → exec의 전형적인 사용 예
- exec 계열 : 인자와 환경 변수의 전달 방법에 따라 이름이 조금씩 다른 execXX들
    - 리눅스 포함 대부분 유닉스계 운영체제에서는 execve()만 시스템 콜, 나머지는 라이브러리 함수
    - l : 실행할 프로그램의 실행 인자를 함수의 가변 인자로 전달
    - v : 실행 인자를 문자열 배열로 전달
        
        → 두 경우 모두 지정한 인자는 실행되는 프로세스의 main()의 argv가 됨
        
    - e : 마지막 인자로 환경 변수인 envp가 추가됨
        → e가 붙어 있지 않은 API는 현재 프로세스의 환경 변수를 그대로 사용
    - p : 첫 번째 인자인 program을 환경 변수 PATH에서 찾음
        → p가 붙어 있지 않은 경우 첫 번째 인자인 path를 절대 경로 또는 상대 경로로 지정해야함
- exec는 성공하면 호출이 돌아오지 않음
    - 호출이 돌아온 경우는 언제나 실패했음을 의미
    - 실패했을 때는 -1을 반환하고 errno에 에러 번호가 설정됨

## wait(2)

- fork()를 호출한 프로세스의 종료를 기다리려면 wait()나 waitpid()를 사용
- wait()는 자식 프로세스 중 어느 하나가 끝나는 것을 기다림
- waitpid()는 첫 번째 인자로 지정한 pid에 해당하는 프로세스가 끝나는 것을 기다림
    - status는 자식 프로세스의 종료 상태를 얻기 위해 사용됨
        
        → 종료 상태 : 종료 방법을 나타내는 플래그 + exit()의 인자로 전달된 값(종료 코드)
        

## 프로세스 API 사용

1. fork()
2. 자식 프로세스에서 새로운 프로그램을 exec
3. 부모 프로세스는 자식 프로세스를 wait


# 프로세스의 생애

## _exit(2)

- 프로세스를 자발적으로 종료하는 시스템 콜
- 인자로 지정한 status를 종료 상태로 하여 프로세스를 종료
- 절대 실패하지 않고, 호출한 곳으로도 돌아가지 않음

## exit(3)

- 라이브러리 함수
- 인자로 지정한 status를 종료 상태로 하여 프로세스를 종료
- 절대 실패하지 않고, 호출한 곳으로도 돌아가지 않음

## exit()과 _exit()의 차이

- exit()은 stdio의 버퍼를 전부 해제
- exit()은 atexit()으로 등록한 처리를 실행
    
    ⇒ exit()의 경우 libc의 함수이기 때문에 libcf와 관련한 각종 뒤처리를 수행함
    
    ⇒ _exit()은 시스템 콜이기 때문에 libc에 대한 뒤처리를 할 수 없음
    
- main()에서 return문을 만나면 프로그램이 종료되는데, 이때도 내부적으로 exit()이 호출되어 종료됨

## 종료 상태

- 보통 exit()을 사용할 때 exit(0)이나 exit(1)처럼 상숫값을 직접 넣어 사용함
- 0은 성공, 1은 실패라는 것이 리눅스(유닉스)에선 맞지만 다른 시스템에서는 다를 수 있음
- 성공, 실패 중 어느 하나를 표현하는 것이라면 EXIT_SUCCESS와 EXIT_FAILURE라는 매크로를 사용하는 편이 더 좋음
- 성공, 실패 외에 더 상세한 상태를 표현하고 싶다면 직접 수치를 사용해야함

## 프로세스의 생애

1. fork()
2. exec → 자식 프로세스 수행
3. 자식 프로세스가 _exit()으로 종료
4. 자식 프로세스의 종료 상태를 부모 프로세스의 wait()이 받아들임

## 좀비 프로세스

- 자식 프로세스의 실행이 종료되었지만 부모 프로세스가 wait()을 호출하지 않은 경우는?
- 커널의 입장에서는 부모 프로세스가 언제 wait()을 호출할 지 알 수 없음
    
    → 커널은 자식 프로세스의 실행이 끝났어도 부모 프로세스가 종료되거나 wait()을 호출하기 전까지 상태 코드를 보관함
    
- 실행이 종료되었지만 부모가 wait()을 호출하기 전까지 커널이 그 상태 코드를 보관하고 있는 자식 프로세스를 좀비 프로세스(zombie process)라고 함

### 좀비  프로세스를 막는 방법

- 금방 종료하는 프로그램이라면 자식 프로세스 일부가 좀비 프로세스가 되더라도 큰 문제가 없지만 장시간 작동하는 프로세스의 자식이 좀비가 되면 시스템이 좀비 프로세스로 차게 됨
- 프로세스의 수가 증가하면 커널의 부담이 커지므로 시스템에도 좋지 않음
- 자식 프로세스가 좀비 프로세스가 되지 않도록 하는 방법
    1. fork()하면 wait()하기
        
        가장 정석적인 방법. fork()하면 wait()하는 것이 부모 프로세스의 책임이다.
        
    2. 이중 fork
        
        자식 프로세스에서 한 번 더 fork()를 하는 것.
        
        wait()하는 권리는 바로 직계 부모에게만 있으므로 자식 프로세스가 없어지면 손자 프로세스를 wait() 할 수 있는 권리를 가진 프로세스도 없어짐.
        
        커널도 손자 프로세스를 좀비로 두지 않고 종료하면 즉시 정리하게 됨.
        
    3. sigacion()
        
        wait()하지 않도록 커널에 알리는 API

# 파이프

## 파이프

- 프로그래머 관점에서 보면, 파이프는 프로세스와 프로세스 간에 연결된 스트림이다.
- 파일에 연결된 스트림처럼 파이프도 파일 디스크립터를 사용하여 표현된다.
- 보통 파일에 연결된 스트림은 읽고 쓰기를 겸할 수 있지만, 파이프는 단방향이다.
    - 하나의 파일 디스크립터에 대해서는 읽기나 쓰기 둘 중 하나만 할 수 있다.

## pipe(2)

```c
#include <unistd.h>

int pipe(int fds[2]);
```

- pipe()는 호출한 프로세스에 연결된 스트림을 만들고 그 양쪽의 파일 디스크립터 두 개를 인자로 전달한 fds에 써넣고 반환한다.
- fds[0]은 읽기 전용, fds[1]은 쓰기 전용이다.

## 부모/자식 프로세스 사이를 파이프로 연결하기

- pipe()는 단독으로는 거의 의미가 없고 fork()와 결합해야 비로소 의미가 있다.
- fork()를 하면 프로세스가 복제되면서 스트림도 모두 복제가 된다.
- pipe() → fork()를 한 뒤, 부모와 자식이 파이프를 각각 하나씩 close()하면 부모로부터 자식으로 연결된 파이프가 구성된다.
- 그다지 직관적인 방법은 아니다.

## dup(2), dup2(2)

```c
#include <unistd.h>

int dup(int oldfd);
int dup2(int oldfd, int newfd);
```

- 표준 입력과 표준 출력을 파이프로 연결하기 위해서는 dup()이 필요하다.
- dup()와 dup2()는 파일 디스크립터 oldfd를 복제한다.
- dup2()는 파일 디스크립터 oldfd를 지정한 파일 디스크립터 newfd에 복제한 뒤 그것을 반환하며, 에러가 발생하면 -1을 반환한다.
- ‘복제한다’는 것은 하나의 스트림을 커널 안에서 두 개로 분기하는 것을 의미한다.

### 목표한 번호의 파일 디스크립터에 파이프를 연결하는 방법

- 3번에 연결된 파이프를 0번으로 옮기고 싶을 경우
    1. close(0);
    2. dup2(3, 0);
    3. close(3);

# 스트림 관련 시스템 콜

- 유닉스의 입출력은 대부분 네 개의 시스템 콜로 처리된다.
    - 스트림에서 바이트 열을 읽는 read
    - 스트림에 바이트 열을 쓰는 write
    - 새로운 스트림을 생성하는 open
    - 사용 완료한 스트림을 닫는 close

## 파일 디스크립터

- 파일 디스크립터(file descriptor) : 커널이 스트림을 열 때 부여하는 번호
- 파일 디스크립터를 알아야 스트림을 본격적으로 사용할 수 있다.

## 표준 입력, 표준 출력, 표준 에러 출력

- 셸을 통해 프로세스가 생성되는 경우, 세 개의 스트림이 기본으로 생성되고, 이에 대한 파일 디스크립터 값이 미리 할당된다.
- 각각 표준 입력(standard input), 표준 출력(standard output), 표준 에러 출력(standard error output)이고 파일 디스크립터 0번, 1번, 2번에 할당된다.
- 매크로에 STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO로 등록되어 있다.

### 표준 입력과 표준 출력

- 여러 명령어를 파이프로 연결하여 데이터를 처리하는 것이 가능한 것은 각 명령어가 표준 입력에서 데이터를 읽고 처리 결과를 표준 출력에 쓰게 되어 있기 때문이다.
- 이 경우 ‘표준’은 ‘디폴트’에 가까운 의미다.

### 표준 에러 출력

- 에러 메세지를 출력하기 위해 사용한다.
- 일반적으로 표준 출력은 파이프라인을 통해 다음 프로그램의 표준 입력에 연결된다.
- 에러 메세지를 표준 출력으로 내보내면 사람이 에러 발생을 알기 어렵게 된다.
- 그렇기 때문에 여분의 스트림을 준비해 일반 메세지는 파이프라인을 통해 표준 출력으로, 에러 메세지는 표준 에러 출력으로 출력하도록 한 것이다.

## 스트림 읽기 및 쓰기

### read(2)

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t bufsize);
```

**설명**

- 스트림에서 바이트 열을 읽기 위해 사용하는 시스템 콜
- 파일 디스크립터 번호인 `fd`에 해당하는 스트림에서 바이트 열을 읽는다.
- 최대 `bufsize` 바이트 수를 읽어 `buf`에 기록한다.

**반환값**

- `read()`는 읽기 작업이 순조롭게 완료되면 읽어 들인 바이트 수를 반환한다.
- 파일의 끝에 도달한 경우 0을 반환하고, 중간에 에러가 발생한 경우 -1을 반환한다.

**주의점**

- `bufsize` 바이트 수보다 적은 바이트 수를 읽는 경우도 많으므로 반환값을 체크해야 한다.
- `read()`는 읽어 들인 데이터의 끝에 ‘\0’이 있다고 전제하지 않는 API이다.
- 예를 들어 `printf()`는 문자열의 끝에 ‘\0’이 있다고 전제하는 API이므로 `read(2)`로 읽은 문자열을 그대로 `printf()`로 전달해서는 안된다.

### write(2)

```c
#include <unistd.h>

ssize_t write(int fd, const *buf, size_t bufsize);
```

- 스트림에 바이트 열을 쓸 때 사용하는 시스템 콜
- 인자로 지정한 `bufsize` 바이트만큼 `buf`의 내용을 `fd`로 지정한 파일 디스크립터의 스트림에 쓴다.
- 반환값의 데이터 타입인 `ssize_t`는 부호 있는 정수를 의미한다.
- 정상적으로 쓴 바이트 수를 반환하고 에러가 발생한 경우에는 -1을 반환한다.
- `write()`가 `bufsize`로 지정한 바이트 수만큼 쓸 수 없는 상황은 비교적 드물지만, 발생한 여지는 충분히 있기 때문에 정확한 처리가 필요한 경우 반환값을 체크해야 한다.

### 스트림이란?

- 스트림은 파일 디스크립터로 표현되고, `read()`나 `write()`를 통해 읽고 쓸 수 있다.
- 예를 들어 파일을 `open()`하면 `read()`나 `write()`를 통해 파일의 내용을 읽거나 쓸 수 있는데 이것이 스트림이다.
- 파이프라인이나 소켓도 스트림이다.