
# man 페이지의 섹션 구분

| 섹션 | 분류 |
| --- | --- |
| 1 | 실행 가능한 프로그램이나 셸 명령어 |
| 2 | 시스템 콜 |
| 3 | 라이브러리 함수 |
| 4 | 특별한 파일들(디바이스 파일 등) |
| 5 | 파일 포맷 |
| 6 | 게임 |
| 7 | 규격 등 |
| 8 | 시스템 관리용 명령어 |
- 콘솔에서 `man <찾을 명령>` 을 입력하면 섹션 1부터 차례대로 조사해서 제일 먼저 발견한 섹션의 페이지를 표시해 준다.
- `man <섹션> <찾을 명령>` 과 같이 중간에 섹션 번호를 넣으면, 해당 섹션에 한해서만 검색한다.
- 여러 섹션에 동일한 이름의 페이지가 존재할 수도 있다.
    - printf의 경우 섹션 1과 3에 존재한다.
    - `man printf` 라고 입력하면 제일 먼저 발견되는 섹션 1이 표시된다.
    - 라이브러리 함수과 관련된 printf를 보고 싶으면 `man 3 printf` 라고 입력해야 한다.
- man의 섹션 번호는 리눅스나 유닉스와 관련된 문서에서도 자주 사용된다.
    
    → 명령어 printf는 `printf(1)` , 라이브러리 함수 printf는 `printf(3)` 라고 표시


# 커널

- 커널(kernel)이란, 사물의 중심이란 뜻을 가지며 운영체제의 중심을 의미한다.
- 보통 커널은 하나의 프로그램으로 구성되어 컴퓨터를 구성하는 모든 하드웨어와 소프트웨어를 관리한다.
- 리눅스의 루트 경로(/)나 /boot 디렉토리에서 `ls` 명령어를 실행해 보면 `vmlinuz` 라는 이름의 파일이 있는데 이것이 리눅스 커널의 본체다.
- 엄밀히 말해 ‘리눅스'라고 하면 오직 커널만을 의미한다.

# 시스템 콜

- 하드웨어를 직접 다루는 건 커널만이 할 수 있다.
- 일반 프로그램이 하드웨어를 조작하기 위해서는 커널에 의뢰해야만 한다.
- 일반 프로그램이 커널에 디바이스 조작 작업을 의뢰하기 위해 사용하는 것이 **시스템 콜**(system calll)이다.
    - 시스템 콜이라는 이름에서 시스템은 커널을 의미한다.
- 시스템 콜의 종류는 아래와 같다.
    
    `open, read, write, fork, exec, stat, unlink`
    
- 리눅스의 핵심에는 커널이 있고 이 커널에 일을 맡기기 위해 시스템 콜을 사용한다.
# 파일 시스템

## 파일

- 리눅스에서 파일은 세 가지 경우로 나누어 생각해 볼 수 있다.
    1. 넓은 의미의 파일
    2. 좁은 의미의 파일
    3. 스트림

## 넓은 의미의 파일

  - `ls` 명령어를 치면 나오는 텍스트 파일, 바이너리 파일, 디렉터리, 심볼릭 링 크 모두 파일이다.

### 보통 파일

- 가장 일반적인 것으로 데이터가 들어 있는 파일이다.
- regular file 혹은 normal file이라고 한다.
- 좁은 의미에서 파일의 정의는 보통 이러한 보통 파일만을 말한다.
- 사람의 관점에서는 텍스트 파일, 영상 파일, 이미지 파일  등으로 구분할 수 있지만, 커널 입장에서는 그저 같은 보통 파일이다.

### 디렉터리

- 디렉터리(directory)는 다른 파일(넓은 의미의 파일)들을 담아 둘 수 있는 파일이다.
- 유닉스에서는 전통적으로 디렉터리의 데이터를 단순한 바이트 열로 읽는 것이 가능했지만 리눅스에서는 금지했다.

### 심볼릭 링크

- 심볼릭 링크(symbolic link)란, 다른 파일을 가리키는 파일을 말한다.
- 소프트 링크(soft link)라고도 한다.
- 심볼릭 링크 파일을 열면, 커널이 자동으로 연결된 파일을 열어 준다.
- 심볼릭 링크를 사용하면 파일아니 디렉터리에 다른 이름, 즉 별명을 부여할 수 있다.

### 디바이스 파일

- 디바이스 파일(device file)이란, 디바이스(하드웨어)를 파일로 표현한 것이다.
- 예를 들어 디바이스 파일 `/dev/sda` 는 첫 번째 SSD 혹은 HDD를 의마한다.
- 디바이스 파일은 다루는 하드웨어에 따라 **문자 디바이스 파일**(character device file)과 **블록 디바이스 파일**(block device file)이 있다.
    - 차이점은 원하는 시점에 원하는 곳에 접근할 수 있는지다.
    - SSD와 HDD는 대표적인 블록 디바이스다.
    - 프린터나 모뎀은 문자 디바이스다.

### 명명된 파이프

- 명명된 파이프(named pipe)는 프로세스 간 통신에 사용되는 파일이다.
- FIFO라고도 불린다.
- 명명된 파이프는 사용 빈도가 높지 않다.

### UNIX 도메인 소켓

- 유닉스 도메인 소켓도 프로세스 간 통신에 사용되는 파일이다.
- 현재는 TCP 소켓으로 대체되었다.

## 메타 정보

- 파일에는 데이터 그 자체 외에도 다양한 정보가 존재한다.
- 파일의 종류, 권한, 크기, 마지막 수정 시간이 존재한다.

## 파일에 대한 특징 정리

- 어떤 데이터를 보유한다.
- 메타 정보가 있다
- 이름(경로)으로 지정할 수 있다.

⇒ 이와 같은 특징을 가지는 파일을 관리하는 시스템이 바로 파일 시스템이다.

## 파일 시스템과 마운트

- 파일 시스템은 당연하게도 SSD나 HDD, USB 메모리처럼 물리적인 기억 장치에 존재한다.
- 예를 들어 SSD나 HDD의 경우, 먼저 디스크를 **파티션**(partition) 단위로 나눠 그 위에 파일 시스템을 얹어서 **마운트**(mount)하면 거대한 디렉터리 트리가 생성된다.
- 리눅스에서 사용할 수 있는 파일 시스템 중 몇 가지는 다음과 같다.
    - ext4 : 현재 리눅스에서 가장 일반적으로 사용되는 파일 시스템
    - xfs : 구 SGI 사가 제공한 저널링 파일 시스템
    - btrfs : 리눅스 ㅅ향 copy-on-write B tree 파일 시스템
    - 이 외에도 물리적인 디바이스가 존재하지 않는 가상 파일 시스템(pseudo file system)이 있다.
# 프로세스 API

## fork(2)

- 프로세스 자신을 복제해서 새로운 프로세스를 만드는 시스템 콜
- fork()를 호출하면 커널이 프로세스를 복제해서 두 개의 프로세스로 분리함
    - 이 시점에서 ‘복제 이전 프로세스’와 ‘복제 이후 프로세스’ 모두 fork() 호출이 끝난 상태
    - 둘 다 fork() 이후의 코드가 실행됨
- 부모 프로세스(parent process)
    - fork() 전부터 존재하던 프로세스
    - fork()의 반환값은 자식 프로세스의 프로세스 ID 값(양수)
- 자식 프로세스(child process)
    - fork()로 복제해서 만들어진 프로세스
    - fork()의 반환값은 0
- fork()가 실패한 경우 자식 프로세스가 생성되지 않고 부모 프로세스에 -1 반환

## exec

- 프로세스 자기 자신을 새로운 프로그램으로 덮어 쓰는 시스템 호출
- exec를 실행하면 그 시점에서 현재 실행 중인 프로그램이 소멸하고, 새로운 프로그램을 로드하여 실행
- fork() 후 즉시 exec → exec의 전형적인 사용 예
- exec 계열 : 인자와 환경 변수의 전달 방법에 따라 이름이 조금씩 다른 execXX들
    - 리눅스 포함 대부분 유닉스계 운영체제에서는 execve()만 시스템 콜, 나머지는 라이브러리 함수
    - l : 실행할 프로그램의 실행 인자를 함수의 가변 인자로 전달
    - v : 실행 인자를 문자열 배열로 전달
        
        → 두 경우 모두 지정한 인자는 실행되는 프로세스의 main()의 argv가 됨
        
    - e : 마지막 인자로 환경 변수인 envp가 추가됨
        → e가 붙어 있지 않은 API는 현재 프로세스의 환경 변수를 그대로 사용
    - p : 첫 번째 인자인 program을 환경 변수 PATH에서 찾음
        → p가 붙어 있지 않은 경우 첫 번째 인자인 path를 절대 경로 또는 상대 경로로 지정해야함
- exec는 성공하면 호출이 돌아오지 않음
    - 호출이 돌아온 경우는 언제나 실패했음을 의미
    - 실패했을 때는 -1을 반환하고 errno에 에러 번호가 설정됨

## wait(2)

- fork()를 호출한 프로세스의 종료를 기다리려면 wait()나 waitpid()를 사용
- wait()는 자식 프로세스 중 어느 하나가 끝나는 것을 기다림
- waitpid()는 첫 번째 인자로 지정한 pid에 해당하는 프로세스가 끝나는 것을 기다림
    - status는 자식 프로세스의 종료 상태를 얻기 위해 사용됨
        
        → 종료 상태 : 종료 방법을 나타내는 플래그 + exit()의 인자로 전달된 값(종료 코드)
        

## 프로세스 API 사용

1. fork()
2. 자식 프로세스에서 새로운 프로그램을 exec
3. 부모 프로세스는 자식 프로세스를 wait
